
# DB 정규화 2부(쉬운코드 유튜버 강의)

참고 강의

https://youtu.be/5QhkZkrqFL4?si=BlIQcM5VqIH4896V

---

- 지난 시간까지 1NF, 2NF를 마친 상태임.
<img width="1239" height="526" alt="image" src="https://github.com/user-attachments/assets/6203fb05-480b-4c87-ac32-a952a21e6756" />

- 위의 테이블을 관찰해보면
- {account_id} → {empl_id}, {empl_id} → {empl_name}의 FD관계라는 것을 확인할 수 있다. 이를 {account_id} → {empl_name}이라고 생각해도 의미적으로 무방하다.
- 또한,
- {bank_name, account_num} → {empl_id}, {empl_id} → {empl_name}이고, {bank_name, account_num} → {empl_name}의 FD관계라고 생각해도 무방하다!
- 이처럼, X→Y, Y→Z일 때, X→Z를 transitive FD라고 한다. 단, Y or Z가 key의 subset이면 안 된다.(X, Y=non-prime attribute)


## 3NF

: 모든 non-prime attribute는 어떤 key에도 transitively dependent하면 안 된다. non-prime attribute와 non-prime attribute 사이에는 FD가 있으면 안 된다.
- non-prime attribute: class, ratio, empl_id, empl_name
- 아래와 같이 수정하면 3NF를 만족하게 된다!

<img width="1265" height="582" alt="image" src="https://github.com/user-attachments/assets/c9da87d1-0a42-46fc-a4d8-5adf4761a830" />




## BCNF

: 모든 유효한 non-trivial FD X→Y는 X가 super key여야 한다.

- non-trivial FD: Y가 X의 부분집합이 아닌 FD 관계
- super key: 튜플들을 유니크하게 구별해주는 key
- 즉, 튜플들을 유니크하게 구별해주는 X, Y는 X의 부분집합이 아니다.
- {class} → {bank_name}: FD 관계. completely non-trivial FD. {class}는 super key 아님!

⇒ BCNF 위반! class를 다른 테이블로 쪼개서 BCNF를 만족시켜줘야 함

<img width="1191" height="603" alt="image" src="https://github.com/user-attachments/assets/9ef1bdcc-8c33-45e9-bdc6-ed460a0d1509" />

<img width="1282" height="672" alt="image" src="https://github.com/user-attachments/assets/478eaefb-c3ca-4bba-b19d-805ecb09bee8" />

- 이제 class 이름을 join해줘서 bank_name을 가져올 수 있음!


- 최종적인 테이블
<img width="1331" height="701" alt="image" src="https://github.com/user-attachments/assets/d5e47aea-0415-46ee-8ab9-0d49ba4c5017" />


## 2NF 참고 사항: 2NF는 key가 composite key가 아니라면 2NF는 자동적으로 만족한다?

- 2NF: 모든 non-prime attribute는 모든 key에 fully dependent 해야 한다. = 모든 non-prime attribute는 어떤 key에도 partially dependent 하면 안 된다.
- ⇒ 결과적으로 “일반적인 경우” 2NF는 key가 composite key가 아니라면 2NF는 자동적으로 만족할 것이다.
- ⇒ “BUT!!! 예외가 존재함!!!”
    - { } → {company}가 있을 때!!!!
    - {empl_id} → {empl_name, birth_date, position, salary, company}에서 { }은 {empl_id}의 부분집합이 됨




## Denormalization

- 그런데, 이렇게까지 테이블을 쪼개야 할까? 테이블을 자꾸 쪼개면 오히려 여러 테이블들이 동시에 조인하게 되면서 느려지게 되고, 관리도 어렵게 된다.

⇒ 그래서 등장한 개념 - denormalization(반정규화, 역정규화)

- ex. BCNF까지 만족시키려고 하니까 테이블을 너무 많이 쪼갠 것 같다.. 3NF까지만 정규화하자! 다시 BCNF에서 3NF의 테이블 형태로 합치는 과정을 denormalization!
