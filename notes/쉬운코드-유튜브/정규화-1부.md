# DB 정규화 1부(쉬운코드 유튜버 강의)

참고 강의

https://youtu.be/EdkjkifH-m8?si=C7EiabroqNtVn7Wu

---

- FD를 사용해서 DB를 정규화할 것!
- DB 정규화: 데이터 중복과 insertion, update, deletion anomaly를 최소화하기 위해 일련의 normal forms(NF)에 따라 relational DB를 구성하는 과정

---

## DB 정규화 과정
    
<img width="911" height="246" alt="image" src="https://github.com/user-attachments/assets/3bc2e1f5-7f37-4b33-ad12-61bb4aec1baa" />

- 처음부터 “순차적으로” 진행하며 NF를 만족하지 못하면 테이블 구조를 조정하여 NF를 만족하도록 한다.
- FD와 key만으로 정의되는 normal forms → ??
- 보통 실무에서는 3NF 혹은 BCNF까지만 진행(3NF까지 도달해도 정규화됐다고 말하기도 함.)


---

- 스키마와 조건
<img width="962" height="463" alt="image" src="https://github.com/user-attachments/assets/bc191297-c57f-4325-87e4-855b42f1d86b" />

--- 

- key 복습
    - super key
    - (candidate) key
    - primary key
    - prime attribute: 임의의 key에 속하는 attribute
    - non-prime attribute: 어떠한 key에도 속하지 않는 attribute

---

- key와 FD 찾아보기
<img width="995" height="327" alt="image" src="https://github.com/user-attachments/assets/de8dd0dc-96a6-4ed0-861d-7896671765d0" />

---

- 주의: FD는 X → Y가 일대일 대응만 가능한 것이 아님. 다대일 매핑이어도 상관없음. X에 따라 Y가 같은 값만 나오면 모두 성립!!
    - ex. {class} → {bank_name}

- 일대일 함수 관계인 X, Y
<img width="484" height="434" alt="image" src="https://github.com/user-attachments/assets/82bb310e-2a4d-47b6-8042-3db8b985fb3b" />

- 일대일 대응 관계인 X, Y
<img width="472" height="448" alt="image" src="https://github.com/user-attachments/assets/b673861d-4c65-4a7f-bdc1-62e13ec02f40" />

- 사진 참고: https://www.inoder.com/lecture/583/ 


---

- 참고: 원래 정규화는 스키마만 보고 하는 것!



## 1NF

: attribute의 value는 반드시 나눠질 수 없는 단일한 값이어야 한다.

- 아래 예시는 1NF를 위반하고 있음

  <img width="1351" height="446" alt="image" src="https://github.com/user-attachments/assets/eaa556f1-a83a-4c33-8476-36378494a698" />

<img width="1375" height="481" alt="image" src="https://github.com/user-attachments/assets/57313927-4e66-4bde-be1f-a6484ec32c79" />


- 1NF를 만족하게 됐지만, 중복 데이터가 생기게 된다!
    - account_id가 유니크하지 않아졌으며
    - 한 직원의 ratio의 합이 1이 아님
- 왜 중복 데이터가 생겼을까? 원래 (candidate) key가 {account_id}, {bank_name, account_num}이었음
- 하지만, 1NF를 해결하면서 key가 {account_id, card_id}, {bank_name, account_num, card_id}로 바뀜. 즉, card_id를 포함해야하는 상태가 되었다!
- 용어: non-prime attribute: key에 속하지 않는 attribute들
- non-prime attribute: class, ratio, emp_id, emp_name
- 다시 테이블을 관찰해보면,
    - key는  {account_id, card_id}, {bank_name, account_num, card_id}로 바뀌었지만,
    - {account_id} → {non-prime attributes}
    - {bank_name, account_num} → {non-prime attributes}
    - 라는 FD 관계는 변하지 않았음!
    - 즉, 모든 non-prime attribute들이 {account_id, card_id}에 partially dependent하다! 마찬가지로, {bank_name, account_num, card_id}에 partially dependent하다!
        - non-prime attributes가 {account_id}(={account_id, card_id}의 진부분집합)로도 FD관계가 성립함!




## 2NF

: 모든 non-prime attribute는 모든 key에 full functionally dependent 해야 한다.

<img width="1366" height="754" alt="image" src="https://github.com/user-attachments/assets/bac0c827-f2ff-40be-993d-6791c248fdd5" />

- card_id를 따로 떼어낸다. + account_id를 함께 작성하여 나중에 조인할 수 있게 함!
- 그리고, 중복 데이터를 삭제한다!
- 결과적으로, account_id에 대해서 모든 튜플이 유니크해졌다!
- ({bank_name, account_num}에 대해서도 유니크함이 성립해짐!)
- 두 테이블 모두 2NF를 만족하게 됐다!!



